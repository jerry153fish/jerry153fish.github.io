---
layout: post
title: DotNet Study Note 1 - C# language
key: 20180128
tags: C# DotNet Note
---

This is first part of DotNet study notes -- quick review for C# language.


### Concepts

- Component Object Model COM -- .NET libraries are not registered into the system registry NOT LIKE COM

- Common Intermediate Language (CIL) 
- just-in-time (JIT) compilation
- Common Language Runtime (CLR)
    - to locate, load, and manage .NET objects
    - takes care of a number of low-level details such as memory management, application hosting, coordinating threads, and performing basic security checks
- the Common Type System (CTS)
    - describes all possible data types and all programming constructs supported by the runtime
    - specifies how these entities can interact with each other
    - indicates details how they are represented in the .NET metadata format 
- Common Language Specification (CLS)
    - defines a subset of common types and programming constructs that all .NET programming languages can agree on
- Base Class Libraries
    - define types that can be used to build any type of software application

![CLR](/assets/img/csharp/clr.png)[^1]


### C# Features

- No pointers required!
- Automatic memory management through garbage collection. Given this, C# does not support a delete keyword.
- Formal syntactic constructs for classes, interfaces, structures, enumerations, and delegates
- The C++-like ability to overload operators for a custom type, without the complexity 
- Support for attribute-based programming. 
- The ability to build generic types and generic members.
- Support for anonymous methods
- The ability to define a single type across multiple code files using the partial keyword
- Support for strongly typed queries (e.g., LINQ) used to interact with various forms of data. 
- Support for anonymous types that allow you to model the structure of a type (rather than its behavior) on the fly in code
- The ability to extend the functionality of an existing type (without subclassing) using extension methods.
- Inclusion of a lambda operator (=>), which even further simplifies working with .NET delegate types.
- A new object initialization syntax, which allows you to set property values at the time of object creation.
- Support for optional method parameters, as well as named method arguments.
- Support for dynamic lookup of members at runtime via the dynamic keyword.
- Working with generic types is much more intuitive, given that you can easily map generic data to and from general System

> C# 6

- Inline initialization for automatic properties as well as support for read-only automatic properties
- Single-line method implementations using the C# lambda operator
- Support of static imports to provide direct access to static members within a namespace
- A null conditional operator, which helps check for null parameters in a method implementation
- A new string-formatting syntax termed string interpolation
- The ability to filter exceptions using the new when keyword
- Using await in catch and finally blocks
- nameOf expressions to return a string representation of symbols
- Index initializers
- Improved overload resolution

> C# 7

- Declaring out variables as inline arguments
- Nesting functions inside other functions to limit scope and visibility
- Additional expression-bodied members
- Generalized async return types
- New tokens to improve readability for numeric constants
- Lightweight unnamed types (called tuples) that contain multiple fields
- Updates to logic flow using type matching in addition to value checking (pattern matching)
- Returning a reference to a value, instead of just the value itself (ref locals and returns)
- The introduction of lightweight throwaway varials (called discards)
- Throw expressions, allowing the throw to be executed in more places, such as conditional expressions, lambdas, and others
- The ability to have a program’s main method be async.
- A new literal, default, that allows for initialization of any type.
- Correction of an issue with pattern matching that prevented using generics with the new pattern matching feature.
- Like anonymous methods, tuple names can be inferred from the projection that creates them.

### .NET Assemblies

NET binaries do not contain platform-specific instructions but rather platform-agnostic Intermediate Language (IL) and type metadata. Il is also known as Microsoft intermediate language (Msil) or alternatively as the Common intermediate language (Cil).

In addition to CIL instructions, assemblies also contain metadata that describes in vivid detail the characteristics of every “type” within the binary. DotNET metadata is always present within an assembly and is automatically generated by a .NET-aware language compiler. 

Assemblies themselves are also described using metadata, which is officially termed a manifest. The manifest contains information about the current version of the assembly, culture information (used for localizing string and image resources), and a list of all externally referenced assemblies that are required for proper execution.

### CTS

Type is simply a general term used to refer to a member from the set {class, interface, structure, enumeration, delegate}.

A type member is constrained by the set {constructor, finalizer, static constructor, nested type, operator, method, property, indexer, field, read-only field, constant, event}. The CTS defines various adornments that may be associated with a given member. eg: visibility trait (e.g., public, private, protected), abstract (to enforce a polymorphic behavior on derived types) as well as virtual (to define a canned, but overridable, implementation), static (bound at the class level) or instance (bound at the object level)

#### CTS Data Types

![CTS Data Type](/assets/img/csharp/ctsdatatype.png)[^1]

### CLS

The CLS is a set of rules that describe in vivid detail the minimal and complete set of features a given .NET-aware compiler must support to produce code that can be hosted by the CLR, while at the same time be accessed in a uniform manner by all languages that target the .NET platform. In many ways, the CLS can be viewed as a subset of the full functionality defined by the CTS.

```cs
// Tell the C# compiler to check for CLS compliance.
[assembly: CLSCompliant(true)]
```

### CLR

.NET runtime provides a single, well-defined runtime layer that is shared by all languages and platforms that are .NET-aware

- it is the agent in charge of resolving the location of an assembly and finding the requested type within the binary by reading the contained metadata. The CLR then lays out the type in memory, compiles the associated CIL into platform-specific instructions, performs any necessary security checks, and then executes the code in question.

- interact with the types contained within the .NET base class libraries when required. **mscorlib.dll** is the key assembly which contains a large number of core types that encapsulate a wide variety of common programming tasks, as well as the core data types used by all .NET languages.


### The Data Type Class Hierarchy

Each type ultimately derives from System.Object, which defines a set of methods
(e.g., ToString(), Equals(), GetHashCode()) common to all types in the .NET base class libraries

Many numerical data types derive from a class named System.ValueType. Descendants of ValueType are automatically allocated on the stack and, therefore, have a predictable lifetime and are quite efficient. On the other hand, types that do not have System.ValueType in their inheritance chain (such as System.Type, System.String, System.Array, System.Exception, and System.Delegate) are not allocated on the stack but on the garbage-collected heap.

![data type hierarchy](/assets/img/csharp/datatypehierarchy.png)[^1]




<a class="fabox" href="/assets/img/csharp/Csharp-review.png" target="_blank"><img src="/assets/img/csharp/Csharp-review.png" alt=""/></a>


### Reference

[^1]: Christian N 2018, **Professional C# 7 and . NET Core 2. 0**, https://www.amazon.com/Pro-NET-Core-Andrew-Troelsen/dp/1484230175

