---
layout: post
title: DotNet Study Note 1 - C# language
key: 20180128
tags: C# DotNet Note
---

This is first part of DotNet study notes -- quick review for C# language.


### Concepts

- Component Object Model COM -- .NET libraries are not registered into the system registry NOT LIKE COM

- Common Intermediate Language (CIL) 
- just-in-time (JIT) compilation
- Common Language Runtime (CLR)
    - to locate, load, and manage .NET objects
    - takes care of a number of low-level details such as memory management, application hosting, coordinating threads, and performing basic security checks
- the Common Type System (CTS)
    - describes all possible data types and all programming constructs supported by the runtime
    - specifies how these entities can interact with each other
    - indicates details how they are represented in the .NET metadata format 
- Common Language Specification (CLS)
    - defines a subset of common types and programming constructs that all .NET programming languages can agree on
- Base Class Libraries
    - define types that can be used to build any type of software application

![CLR](/assets/img/csharp/clr.png)[^1]


### C# Features

- No pointers required!
- Automatic memory management through garbage collection. Given this, C# does not support a delete keyword.
- Formal syntactic constructs for classes, interfaces, structures, enumerations, and delegates
- The C++-like ability to overload operators for a custom type, without the complexity 
- Support for attribute-based programming. 
- The ability to build generic types and generic members.
- Support for anonymous methods
- The ability to define a single type across multiple code files using the partial keyword
- Support for strongly typed queries (e.g., LINQ) used to interact with various forms of data. 
- Support for anonymous types that allow you to model the structure of a type (rather than its behavior) on the fly in code
- The ability to extend the functionality of an existing type (without subclassing) using extension methods.
- Inclusion of a lambda operator (=>), which even further simplifies working with .NET delegate types.
- A new object initialization syntax, which allows you to set property values at the time of object creation.
- Support for optional method parameters, as well as named method arguments.
- Support for dynamic lookup of members at runtime via the dynamic keyword.
- Working with generic types is much more intuitive, given that you can easily map generic data to and from general System

> C# 6

- Inline initialization for automatic properties as well as support for read-only automatic properties
- Single-line method implementations using the C# lambda operator
- Support of static imports to provide direct access to static members within a namespace
- A null conditional operator, which helps check for null parameters in a method implementation
- A new string-formatting syntax termed string interpolation
- The ability to filter exceptions using the new when keyword
- Using await in catch and finally blocks
- nameOf expressions to return a string representation of symbols
- Index initializers
- Improved overload resolution

> C# 7

- Declaring out variables as inline arguments
- Nesting functions inside other functions to limit scope and visibility
- Additional expression-bodied members
- Generalized async return types
- New tokens to improve readability for numeric constants
- Lightweight unnamed types (called tuples) that contain multiple fields
- Updates to logic flow using type matching in addition to value checking (pattern matching)
- Returning a reference to a value, instead of just the value itself (ref locals and returns)
- The introduction of lightweight throwaway varials (called discards)
- Throw expressions, allowing the throw to be executed in more places, such as conditional expressions, lambdas, and others
- The ability to have a program’s main method be async.
- A new literal, default, that allows for initialization of any type.
- Correction of an issue with pattern matching that prevented using generics with the new pattern matching feature.
- Like anonymous methods, tuple names can be inferred from the projection that creates them.

### .NET Assemblies

NET binaries do not contain platform-specific instructions but rather platform-agnostic Intermediate Language (IL) and type metadata. Il is also known as Microsoft intermediate language (Msil) or alternatively as the Common intermediate language (Cil).

In addition to CIL instructions, assemblies also contain metadata that describes in vivid detail the characteristics of every “type” within the binary. DotNET metadata is always present within an assembly and is automatically generated by a .NET-aware language compiler. 

Assemblies themselves are also described using metadata, which is officially termed a manifest. The manifest contains information about the current version of the assembly, culture information (used for localizing string and image resources), and a list of all externally referenced assemblies that are required for proper execution.

### CTS

Type is simply a general term used to refer to a member from the set {class, interface, structure, enumeration, delegate}.

A type member is constrained by the set {constructor, finalizer, static constructor, nested type, operator, method, property, indexer, field, read-only field, constant, event}. The CTS defines various adornments that may be associated with a given member. eg: visibility trait (e.g., public, private, protected), abstract (to enforce a polymorphic behavior on derived types) as well as virtual (to define a canned, but overridable, implementation), static (bound at the class level) or instance (bound at the object level)

#### CTS Data Types

![CTS Data Type](/assets/img/csharp/ctsdatatype.png)[^1]

### CLS

The CLS is a set of rules that describe in vivid detail the minimal and complete set of features a given .NET-aware compiler must support to produce code that can be hosted by the CLR, while at the same time be accessed in a uniform manner by all languages that target the .NET platform. In many ways, the CLS can be viewed as a subset of the full functionality defined by the CTS.

```cs
// Tell the C# compiler to check for CLS compliance.
[assembly: CLSCompliant(true)]
```

### CLR

.NET runtime provides a single, well-defined runtime layer that is shared by all languages and platforms that are .NET-aware

- it is the agent in charge of resolving the location of an assembly and finding the requested type within the binary by reading the contained metadata. The CLR then lays out the type in memory, compiles the associated CIL into platform-specific instructions, performs any necessary security checks, and then executes the code in question.

- interact with the types contained within the .NET base class libraries when required. **mscorlib.dll** is the key assembly which contains a large number of core types that encapsulate a wide variety of common programming tasks, as well as the core data types used by all .NET languages.


### The Data Type Class Hierarchy

Each type ultimately derives from System.Object, which defines a set of methods
(e.g., ToString(), Equals(), GetHashCode()) common to all types in the .NET base class libraries

Many numerical data types derive from a class named System.ValueType. Descendants of ValueType are automatically allocated on the stack and, therefore, have a predictable lifetime and are quite efficient. On the other hand, types that do not have System.ValueType in their inheritance chain (such as System.Type, System.String, System.Array, System.Exception, and System.Delegate) are not allocated on the stack but on the garbage-collected heap.

![data type hierarchy](/assets/img/csharp/datatypehierarchy.png)[^1]

### System String

> String = operation has been written to value comparing

```cs

string t1 = "aa";

t1 == "aa"; // true

```

> StringComparison enumeration

C# Equality/Relational Operator | Meaning in Life
---|---
CurrentCulture | Compares strings using culture-sensitive sort rules and the current culture
CurrentCultureIgnoreCase | Compares strings using culture-sensitive sort rules and the current culture and ignores the case of the strings being compared
InvariantCulture | Compares strings using culture-sensitive sort rules and the invariant culture
InvariantCultureIgnoreCase | Compares strings using culture-sensitive sort rules and the invariant culture and ignores the case of the strings being compared
Ordinal | Compares strings using ordinal (binary) sort rules
OrdinalIgnoreCare | Compares strings using ordinal (binary) sort rules and ignores the case of the strings being compared


### Var

Var is not a C# keyword. it is permissible to declare variables, parameters, and fields named var without compile-time errors. however, when the var token is used as a data type, it is contextually treated as a keyword by the compiler. It is a strongly typed data type.

- var cannot be used as field data!

```cs
class Aa 
{
    private var test = 0; //error
}
```

- var cannot be used as a return value or parameter type!

```cs
// error
var good(var pa)
{

}
```

-  must be assigned an initial value at the exact time of declaration and cannot be assigned the initial value of null

```cs

var a; // error
// error
var b;
b = 3;
// error
var c = null
// ok
var persona = new Person();
person = null;
```

- strongly typed data

```cs

var a = 3;
a = "aa"; // error
```

- go well with linq

### Function modifier

- parameter modifiers

Parameter Modifier | Meaning in Life
---|---
(None) | If a parameter is not marked with a parameter modifier, it is assumed to be passed by value, meaning the called method receives a copy of the original data.
out  | Output parameters must be assigned by the method being called and, therefore, are passed by reference. If the called method fails to assign output parameters, you are issued a compiler error.
ref  | The value is initially assigned by the caller and may be optionally modified by the called method (as the data is also passed by reference). No compiler error is generated if the called method fails to assign a ref parameter.
params | This parameter modifier allows you to send in a variable number of arguments as a single logical parameter. A method can have only a single params modifier, and it must be the final parameter of the method. In reality, you might not need to use the params modifier all too often; however, be aware that numerous methods within the base class libraries do make use of this C# language feature.


### Enum

A data type of name-value pairs and the storage type used to hold the values of an enumeration is a System.Int32 (the C# int).

C# enumerations can be defined in a similar manner for any of the core system types (byte, short, int, or long). 

```cs
// 0 - 255
enum EmpType : byte
{
  Manager = 10,
  Grunt = 1,
  Contractor = 100,
  VicePresident = 9
}
```

### System.ValueType

Ensure that the derived type (e.g., any structure) is allocated on the stack, rather than the garbage-collected heap. Functionally, the only purpose of System.ValueType is to override the virtual methods defined by System.Object to use value-based versus reference-based semantics. 

```cs

struct Person
{
    int age;
}

Person p1 = new Person();
p1.age = 3;
Person p2;
p2 = p1; // value copy
p2.age = 5; // p1.age = 3
```


Intriguing Question | Value Type | Reference Type
---| --- | ---
Where are objects allocated?  | Allocated on the stack. | Allocated on the managed heap.
How is a variable represented? | Value type variables are local copies. | Reference type variables are pointing to the memory occupied by the allocated instance.
What is the base type? | Implicitly extends System. ValueType. | Can derive from any other type (except System.ValueType), as long as that type is not “sealed” 
Can this type function as a base to other types? | No. Value types are always sealed and cannot be inherited from. |Yes. If the type is not sealed, it may function as a base to other types.
What is the default parameter passing behavior? | Variables are passed by value (i.e., a copy of the variable is passed into the called function). | For reference types, the reference is copied by value.
Can this type override System. Object.Finalize()? | No | Yes, indirectly
Can I define constructors for this type? | Yes, but the default constructor is reserved (i.e., your custom constructors must all have arguments). | Yes
When do variables of this type die? | When they fall out of the defining scope. | When the object is garbage collected.

### Nullable types

To define a nullable variable type, the question mark symbol (?) is suffixed to the underlying data type. 

```cs
int? a = 3; // null is ok
bool? test = true; // null is ok
```

the ? suffix notation is a shorthand for creating an instance of the generic System.Nullable<T> structure type.

```cs

bool? test = null; // Nullable<bool> test = null;
```

- The Null Coalescing Operator

```cs
int? a = getSomeIntValue() ?? 100;
```

### Tuples

Lightweight data structures that contain multiple fields. In C# 7, tuples use the new ValueTuple data type instead of reference types.

```cs
// the property names are Item1, Item2, and Item3
(1, "hello", 1.22)

// the property names are FirstLetter, TheNumber, and SecondLetter
(string FirstLetter, int TheNumber, string SecondLetter) valuesWithNames = ("a", 5, "c");
```

### class

A class is a user-defined type that is composed of field data (often called member variables)
and members that operate on this data (such as constructors, properties, methods, events, and so forth). Collectively, the set of field data represents the “state” of a class instance (otherwise known as an object)



<a class="fabox" href="/assets/img/csharp/Csharp-review.png" target="_blank"><img src="/assets/img/csharp/Csharp-review.png" alt=""/></a>


### Reference

[^1]: Christian N 2018, **Professional C# 7 and . NET Core 2. 0**, https://www.amazon.com/Pro-NET-Core-Andrew-Troelsen/dp/1484230175

